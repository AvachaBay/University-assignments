
#Фу́нкция вы́сшего поря́дка - принимает в качестве аргумента другую функцию
#Источник : А. Филд, П. Харрисон Функциональное программирование: Пер. с англ. — М.: Мир, 1993. — 637 с, ил. ISBN 5-03-001870-0. Стр. 55 [Глава 3: Функции высшего порядка].
def main(function, xn,xk):
	
	#Значения для данного метода берутся из результатов прошлого этапа

	#Расчет коэффициентов для преобразования в x->y и обратно
	b=xn
	a=xk-xn
	print("x={0}*y+{1}".format(a,b))

	#Пересчет функции с учётом подстановки результатов прошлого шага вместо x
	def fy(y,a=a,b=b):
		return function(a*y+b)

	teta=(5**(1/2)-1)/2

	#Вывод начального интервала
	y=[0,1-teta,teta,1]
	print('Начальный интервал = ',y)

	l=1  #Переменная отвечающая за длину отрезка
	i=0  #счетчик итераций

	#Основной цикл
	while abs(fy(y[1])-fy(y[2]))>10**(-5) and i!=20:
	 	
		if fy(y[1])>fy(y[2]):
			print ('f({0:.3})={1:.3} > f({2:.3})={3:.3}'.format(y[1],fy(y[1]),y[2],fy(y[2])))
			y[0]=y[1]
			y[1]=y[2]
			l=y[3]-y[0]
			y[2]=y[3]-(1-teta)*l
			print ('Следующая точка y=',y[2])
		else:
			print ('f({0:.3})={1:.3} < f({2:.3})={3:.3}'.format(y[1],fy(y[1]),y[2],fy(y[2])))
			y[3]=y[2]
			y[2]=y[1]
			l=y[3]-y[0]
			y[1]=y[0]+(1-teta)*l
			print ('Следующая точка y={0:.3}'.format(y[1]))

		if abs(fy(y[1])-fy(y[2]))<10**(-5):
			print('Достигнута разница между значениями менее 0.00001 за количество итераций = ',i)
			print('')

		#Вывод интервала с необходимым количеством знаков после запятой = 33 
		P=[]
		P=[round(v,3) for v in y] 
		print('Полученный интервал ',P)
		i+=1

	#Вывод интервала с необходимым количеством знаков после запятой = 33 
	# Вариант #1
	# x=[round(e*a+b,3) for e in y]
	# Вариант №2
	x=list(map(lambda x: round(a*x+b,3), y))
	print('Итоговый интервал для x ',x)


	
if __name__ == '__main__':
	f = lambda x: eval('3*x**4 + (x-1)**2')
	main(f,-3,2)
